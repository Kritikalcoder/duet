
-- evaluate a clipping parameter: return how many
-- rows would be clipped by using that parameter
let evalClippingParam =
            sλ .
               b: 𝔻
               ⇒
               sλ m  : ℕ,
                  n  : ℕ
                  .
                  xs : 𝕄 [L∞, U|m, n⋅𝔻 ]
                  ⇒
  let scaled   = mmap xs { x ⇒ b ⋅ x } in
  let clipped  = mmap (mclip[L2] scaled) { x ⇒ x } in
  let filtered = mfilter zip[clipped, xs] { row  ⇒ 
                   let ⟨clipped, orig⟩ = row#[ℕ[0], ℕ[0]] in
                   clipped ≡ orig } in
  ℝ⁺[0.5] ⋅ real (rows filtered)
in

-- determine the scale of a matrix (i.e. best clipping parameter)
let selectClippingParam =
           pλ m  : ℕ,
              n  : ℕ,
              ε  : ℝ⁺,
              k  : ℕ
              .
              xs : 𝕄 [L∞, U|m, n⋅𝔻 ] ,
              ε  : ℝ⁺[ε],
              bs : 𝕄 [L1, U|1, k⋅𝔻 ]
              ⇒
  let target = 0.9 ⋅ real (rows xs) in
  let fs = mmap bs { b ⇒ evalClippingParam b } in
  bIdx ← AboveThreshold [ ε, fs, target ] <xs> { xs };
  return bs#[idx ℕ[0], bIdx]
in

-- determine the mean of a single column matrix
let colMean = pλ m   : ℕ,
                 k   : ℕ,
                 ε   : ℝ⁺,
                 δ   : ℝ⁺
                 .
                 mat : 𝕄 [L∞, U|m, 1⋅𝔻 ],
                 ε   : ℝ⁺[ε],
                 δ   : ℝ⁺[δ],
                 bs  : 𝕄 [L1, U|1, k⋅𝔻 ]
                 ⇒
  b ← selectClippingParam@[m, 1, ε, k. mat, ε, bs];
  gauss [ℝ⁺[1.0] / (real (rows mat)), ε, δ] <mat> {
    let scaled   = mmap mat { x ⇒ b ⋅ x } in
    let clipped  = mconv (mclip[L1] scaled) in
    let sum      = mfold-row 0.0, clipped { a, r ⇒
                     a + r#[idx ℕ[0], idx ℕ[0]] } in
    sum / (real (rows mat))
  }
in

-- determine the mean of each column in the given matrix
let colMeans = pλ m : ℕ, n : ℕ, k : ℕ, ε : ℝ⁺, δ : ℝ⁺
                  .
                  mat : 𝕄 [L∞, U|m, n⋅𝔻 ],
                  ε   : ℝ⁺[ε],
                  δ   : ℝ⁺[δ],
                  bs  : 𝕄 [L1, U|1, k⋅𝔻 ]
                  ⇒
  pmap-col mat { col ⇒ colMean@[m, k, ε, δ. col, ε, δ, bs] }
in

-- determine the scale of each column in the given matrix
let colScaleParams =
  pλ m : ℕ, n : ℕ, k : ℕ, ε : ℝ⁺, δ : ℝ⁺
     .
     mat : 𝕄 [L∞, U|m, n⋅𝔻 ],
     ε   : ℝ⁺[ε],
     δ   : ℝ⁺[δ],
     bs  : 𝕄 [L1, U|1, k⋅𝔻 ]
     ⇒
  pmap-col mat { col ⇒ selectClippingParam@[m, 1, ε, k. col, ε, bs] }
in

-- given a mean and scale for each column, prepare
-- the given matrix for clipping
let normalize =
  sλ m : ℕ, n : ℕ
     .
     mat    : 𝕄 [L∞, U|m, n⋅𝔻 ],
     means  : 𝕄 [L1, U|1, n⋅𝔻 ],
     scales : 𝕄 [L1, U|1, n⋅𝔻 ]
     ⇒
  -- center the values using the column mean
  let centered = 
    mmap-col mat, means { col, mean ⇒
      mmap col { x ⇒
        x - mean#[idx ℕ[0], idx ℕ[0]]
      }
    } in

  -- scale the values using the clipping parameters
  let centered = 
    mmap-col centered, scales { col, scale ⇒
      mmap col { x ⇒
        x / (disc scale#[idx ℕ[0], idx ℕ[0]])
      }
    } in
in normalize
