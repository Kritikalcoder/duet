-- Presna algorithm
let getXY = sλ m : 𝕄 [L∞ , U | ★ , ℕ ∷ ℕ ∷ ℕ ∷ ℕ ∷ 𝕊∷ [] ] ⇒
  ⟨ row#[0,2], row#[0,3] ⟩
in
let main = pλ ε : ℝ⁺,
              δ : ℝ⁺
              .
              -- interval:ℕ,phone_id:ℕ,x:ℕ,y:ℕ,hash:𝕊
              incoming : 𝕄 [L∞ , U | ★ , ℕ ∷ ℕ ∷ ℕ ∷ ℕ ∷ 𝕊∷ [] ],
              outgoing : 𝕄 [L∞ , U | ★ , ℕ ∷ ℕ ∷ ℕ ∷ ℕ ∷ 𝕊∷ [] ],
              blocks   : set ℕ × ℕ,      -- set of all the blocks of interest
              crisis   : set ℕ × ℕ,      -- set of blocks in crisis
              ε : ℝ⁺[ε],
              δ : ℝ⁺[δ]
              ⇒
  -- NORMAL mode
  q₁ ← parallel outgoing blocks { row ⇒ getXY outgoing }
         { b, p ⇒ noisyCount ← gauss[ℝ⁺[1.0], ε, δ] <outgoing> { rows p };
                  return ⟨b, noisyCount⟩ };

  -- CRISIS mode
  incomingM ← return partitionDF[bools, (mapDF incoming { x ⇒ addColDF ⧼crisis⧽ true })];
  outgoingM ← return partitionDF[bools, (mapDF outgoing { x ⇒ addColDF ⧼crisis⧽ true })];

  -- incomingM[0,0] has a dataframe containing incoming calls to blocks in crisis
  -- incomingM[1,0] has a dataframe containing incoming calls to blocks NOT in crisis
  -- outgoingM[0,0] has a dataframe containing outgoing calls from blocks in crisis
  -- outgoingM[1,0] has a dataframe containing outgoing calls from blocks NOT in crisis
  q₁ ← mgauss[ℝ⁺[1.0], ε, δ] <outgoingM> { mmap (partitionDF[blocks, outgoingM#[1,0]]) { x ⇒ countDF x } } ;
  q₂ ← mgauss[ℝ⁺[1.0], ε, δ] <incomingM> { mmap (partitionDF[blocks, incoming#[1,0]])  { x ⇒ countDF x } } ;
  q₃ ← mgauss[ℝ⁺[1.0], ε, δ] <incomingM, outgoingM> 
         { mmap ( joinDF₁⧼hash⧽[partitionDF[blocks, outgoingM#[0,0]],
                                partitionDF[blocks, incoming#[0,0]]] )
                { x ⇒ countDF x } } ;
  return q₁
in main
