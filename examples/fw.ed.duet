-- frank wolfe (matching the paper)

-- issues:
-- 1. The paper has a bug: The call to exponential returns a signed number which
--    gets used as an idx. This version returns a pair from exponential and (correctly)
--    does the multiplication afterwards.
-- 2. The paper has another bug: "n" is unbound in the 4th line.
-- 3. This version doesn't do clipping (it assumes the input is clipped).
-- 4. We need pairs
-- 5. The paper version uses pattern matching, but this version uses fst[] and snd[]
-- 6. We need vector update (↦)
-- 7. We need idx arithmetic: j mod d better be an "idx d" even if j is an "idx 2d".
-- 8. Doesn't parse
-- 9. Doesn't typecheck

let main = pλ m  : ℕ,
              n  : ℕ,
              ε  : ℝ⁺,
              δ  : ℝ⁺,
              k  : ℕ
              .
              -- xs : 𝕄 [L∞ L∞|m,n] 𝔻, -- FIX: this is so we don't need clipping for now
              -- ys : 𝕄 [L∞ U|m,1] 𝔻,
              xs : 𝕄 [L∞, L∞|m, n⋅𝔻 ] ,
              ys : 𝕄 [L∞, U|m, 1⋅𝔻 ] ,
              ε  : ℝ⁺[ε],
              δ  : ℝ⁺[δ],
              k  : ℕ[k]
              ⇒
--  let k = ℕ[1000] in
--  let δ = ℝ⁺[1.0e-6] in
  let d = cols xs in
  let m₀ = mcreate[ L∞ | ℕ[1] , d ] { i , j ⇒ 0.0 } in
  let indexes = mcreate[ L∞ | ℕ[1] , ℕ[1]⋅d ] { i , j ⇒
                 ⟨ j % dyn d, sign (real (dyn j - dyn d)) ⟩ } in

  aloop[ δ ] k on m₀ <xs,ys> { t , θ ⇒
    let μ = 1.0 / ((real t)+2.0) in
    let s = ℝ⁺[1.0] / real (rows xs) in
    p ← exponential[s, ε] indexes <xs,ys> { x ⇒
          let ⟨c, s⟩ = x in let g = ∇[ LR | θ ; xs , ys ] in g#[idx ℕ[0], c] } ;
    let g₀ = mcreate[ L∞ | ℕ[1] , d ] { i , j ⇒ 0.0 } in
    let gₚ = (let ⟨i, s⟩ = indexes#[idx ℕ[0], p] in g₀#[idx ℕ[0],i ↦ s ⋅ real 100]) in

    let θ'  = mmap θ  { x ⇒ (1.0-μ) ⋅ x } in
    let gₚ' = mmap gₚ { x ⇒ μ ⋅ (100.0 ⋅ x) } in
    return mmap θ', gₚ' { x, y ⇒ x + y }
  }
in main
